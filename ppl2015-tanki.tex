%\documentclass[japanese]{jssst_ppl} %%
 \documentclass[english]{jssst_ppl} %% English
% \documentclass[japanese,draft]{jssst_ppl} %% You can use the draft option
\usepackage{bcprules,amsmath,amsthm,amssymb,amsfonts,extarrows,geometry,amsopn,enumerate}
\usepackage{graphicx}
\usepackage{boxedminipage}
\usepackage{url}

% set some new commands %
\newcommand\tB{\;|\;}
\newcommand\LET{\mathbf{let}\;}
\newcommand\FREE{\mathbf{free(x)}\;}
\newcommand\IN{\mathbf{in}\;}
\newcommand\SKIP{\mathbf{skip}}
\newcommand\Rtab{\; \; \; \;}
\newcommand\NULL{\mathbf{null}}
\newcommand\IFNULL{\mathbf{ifnull}\;}
\newcommand\THEN{\mathbf{then}\;}
\newcommand\ELSE{\mathbf{else}\;}
\newcommand\Lcc{\left(}
\newcommand\Rcc{\right)}
\newcommand\Lfc{\left\{}
\newcommand\Rfc{\right\}}
\newcommand\Lb{\left[}
\newcommand\Rb{\right]}
\newcommand\coma{,\;}
\newcommand\MALLOC{\mathbf{malloc()}\;}
\newcommand\Malloc{\mathbf{malloc}}
\newcommand\Free{\mathbf{free}}
\newcommand\Cirx{(x)}
\newcommand\dtb{\;\;\ \;\;\ \;\;\ \;\;\  }
\newcommand\set[1]{\{#1\}}
\newcommand\VAR{\mathbf{Var}}
\newcommand\OK{\mathit{OK}}
\newcommand\COL{\!:\!}
\newcommand\TSEQ{;\!}
\newcommand\TSKIP{\mathbf{0}}
\renewcommand\rn[1]{\textsc{{#1}}}

\newenvironment{pfof}[1]{%
  {\it Proof of {#1}}:%
}{\qed}


\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{myDef}{Definition}

\theoremstyle{definition}
\newtheorem{exmp}{Example}[section]

\newenvironment{nospaceflalign*}
 {\setlength{\abovedisplayskip}{0pt}\setlength{\belowdisplayskip}{0pt}%
  \csname flalign*\endcsname}
 {\csname endflalign*\endcsname\ignorespacesafterend}

\newcommand\todo[1]{{\bf KS: {#1}}}

\title{A Behavioral Type System for \\ Memory-Leak Freedom}
\author{Qi Tan, Kohei Suenaga, Atsushi Igarashi}
\inst{
    Department of Communications and Computer Engineering\\
    Graduate School of Informatics\\
    Kyoto University\\
\texttt{\{tanki,ksuenaga,igarashi\}@fos.kuis.kyoto-u.ac.jp}
%\medskip\par%
}
\begin{document}
\maketitle
\begin{abstract}
We propose a type system to abstract the behavior of a program under
manual memory management. Our type system uses CCS-like processes as
types where each action corresponds to an allocation and a
deallocation of a fixed-size memory block. The abstraction obtained by
our type system makes it possible to estimate an upper bound of memory
consumption of a program. Hence, by using our type system with another
safe-memory-deallocation analysis proposed by Suenaga and Kobayashi,
we can verify memory-leak freedom even for nonterminating programs.
We define the type system, prove type soundness, and show a type
reconstruction procedure that estimates an upper bound of memory
consumption using an off-the-shelf model checker.
\end{abstract}

\section{Introduction}

Dynamic memory management is a crucial function of programming
languages.  Correct allocation and disposal of memory regions are
fundamental for software to be reliable.

The problem of correct dynamic memory management is challenging if a
programming language is equipped with manual memory management
primitives (e.g., \texttt{malloc} and \texttt{free} in the C
language.)  With such primitives, one can write a program that
accesses to deallocated memory regions (i.e., accesses to dangling
pointers) and that does not dispose memory region when it becomes
unnecessary (i.e., memory leak.)  In order to detect bugs related to
such primitives at the early stage of software development, many
static verification methods have been proposed~\cite{}.

This paper proposes a type-based approach to static verification of
memory-leak freedom that works for nonterminating programs.  Although
memory leaks are relatively more serious in nonterminating programs
(e.g., operating systems and Web servers) than terminating ones, the
analyses proposed so far put less emphasis to nontermination; they
rather verify \emph{partial} memory-leak freedom: if a program
terminates, then all the allocated memory cells are deallocated.  We
say a program is \emph{totally} memory-leak free if it does not
consume unbounded amount of memory during execution.

\begin{exmp}\label{ex:ex1}
%% Functions $h$ and $h'$ shown in Figure~\ref{ex:np} describe
%% memory-leak freedom and memory leaks in nonterminating
%% programs. Function $h$ requires two memory cells at most, whereas
%% function $h'$ requires unbounded number of memory cells to be
%% executed.
\begin{figure}[h]
1  \Rtab $h()$= \dtb \dtb\dtb\Rtab$h'()$= \\
2  \dtb $\LET \; x = \MALLOC  \; \IN$ \dtb \Rtab$\LET \; x = \MALLOC  \; \IN$\\
3  \dtb $\LET \; y = \MALLOC  \; \IN$ \dtb \Rtab$\LET \; y = \MALLOC  \; \IN$\\
4  \dtb $\Free(x)$; $\Free(y) $;\;$h()$ \dtb \Rtab$h'()$; $\Free\Cirx$; \ $\Free(y)$
\caption{Memory leaks in nonterminating programs.}
\label{ex:np}
\end{figure}
Figure~\ref{ex:np} describes partial and total memory-leak freedom.
Both \(h\) and \(h'\) are partially memory-leak free because they do
not terminate.  However, the function \(h'\), when it is invoked,
consumes unbounded number of memory cells; hence \(h'\) is not totally
memory-leak free.  On the other hand, the function \(h\) consumes two
cells at most\footnote{We assume that every memory cell allocated by
  \(\Malloc\) is fixed size.}; hence it is totally memory-leak free.
\end{exmp}

As the first step to the verification of total memory-leak freedom,
this paper proposes a \emph{behavioral type system}~\cite{} for a
programming language with manual memory-management primitives.  Our
type system captures an abstract behavior related to memory allocation
and deallocation as a CCS-like process.  For example, our type system
can assign a type \(
\mu\alpha.\Malloc\TSEQ\Malloc\TSEQ\Free\TSEQ\Free\TSEQ\alpha\) to the
function \(h\) above.  This type expresses that \(h\) can allocate a
memory cell twice, deallocate a memory cell twice, and then iterate
this behavior.  On the other hand, the type assigned to \(h'\) is
\(\mu\alpha.\Malloc\TSEQ\Malloc\TSEQ\alpha\TSEQ\Free\TSEQ\Free\),
which expresses that \(h'\) can allocate a memory cell twice, call
itself recursively, and then deallocate a memory cell twice.  Hence,
by inspecting the inferred types (by using off-the-shelf model
checkers, for example), one can estimate the upper bound required to
execute \(h\) and \(h'\).

Notice that our type system alone does not prevent correct usage of
\(\Malloc\) and \(\Free\).  Indeed, as observed from the type assigned
to \(h\) and \(h'\) above, our types do not include information only
about the number and the order of allocations, deallocations, and
recursive function calls; hence, the type system does not guarantee,
for example, there is no accesses to deallocated cells.  For such
properties, we expect a program to be verified by other
no-illegal-access verifiers~\cite{}.

\todo{USE LABEL to refer to other sections, lemmas, and so on.}  The
rest of this paper is structured as follows. Section 2 introduces a
simple imperative language and the operational semantics of the
language. Section 3 introduces the behavioral type system. Section 4
describes a type reconstruction algorithm.  Section 5 describes
current status and future work.  \todo{To be revised.}

%% \subsection{Motivation and Problems}

%% Manual memory management primitives (e.g., \texttt{malloc} and
%% \texttt{free} in C) often cause that forgetting to deallocate memory
%% cells after use, which we call \emph{memory leaks}. It can diminish
%% the performance of the computer by reducing the amount of available
%% memory cells. Memory leaks may not be serious or even detectable by
%% normal means. Normal memory used by an application is released when
%% application terminates. This means that a memory leak in a program
%% that only runs for a short time may not be noticed and is rarely
%% serious. However, in the real-world programs, nonterminating programs
%% such as Web servers and operating systems are very important. If
%% memory leaks in such nonterminating programs, eventually, too much of
%% the available memory cells may become allocated and all or part of the
%% system stops working correctly~\cite{wiki:xxx}.

%% Most of the static analysis of memory-leak freedom proposed so
%% far~\cite{DBLP:conf/aplas/SuenagaK09,
%%   DBLP:conf/sas/OrlovichR06,DBLP:conf/pldi/HeineL03,DBLP:conf/sigsoft/XieA05,DBLP:journals/scp/SwamyHMGJ06}
%% deal with only \emph{partial memory-leak freedom}: if a program
%% terminates, allocated memory cells are all deallocated at the end. For
%% example, the type system by Suenaga and
%% Kobayashi~\cite{DBLP:conf/aplas/SuenagaK09}, which is called
%% \textbf{SK} type system in our paper, guarantees that (1) a well-typed
%% program does not conduct illegal accesses and that (2) after execution
%% of a well-typed program, all the memory cells are deallocated.

%% We tackle the problem of verifying \emph{total memory-leak freedom} in
%% this paper.\footnote{we often write memory-leak freedom for
%%   \emph{total} memory-leak freedom.} By a program being totally
%% memory-leak free, we mean that the program requires only a bounded
%% amount of memory even if it does not terminate.

%% \subsection{Approach}
%% %% <<<<<<< HEAD
%% %% =======
%% From examples in Figure~\ref{ex:np}, we notice that a simple way to guarantee memory-leak freedom for nonterminating programs is to check whether the number of allocations and deallocations is balanced before recursive call. If balanced, the program consumes bounded number of memory cells, say function $h$ allocates two memory cells and deallocates them before recursive call, it consumes two memory cells at most once; if not balanced, as function $h'$ shows, it allocates two memory cells but does not deallocate them before recursive call, which consumes unbounded number of memory cells as time goes by.
%% %% >>>>>>> 9a92815042ab957eb9b2d406af7a45d4abb729b3

%% From examples in Figure~\ref{ex:np}, we notice that a possible way to
%% guarantee memory-leak freedom for nonterminating programs is to check
%% whether the number of allocations and deallocations is balanced before
%% recursive call. If balanced, the program consumes bounded number of
%% memory cells, say function $h$ allocates two memory cells and
%% deallocates them before recursive call, it consumes two memory cells
%% at most once; if not balanced, as function $h'$ shows, it allocates
%% two memory cells but does not deallocate them before recursive call,
%% which consumes unbounded number of memory cells as time goes by.

%% To estimate the upper bound of memory consumption, we count the number
%% of allocations and deallocations by a behavioral type system. The
%% behavioral type system is mainly used to abstract the behavior of a
%% program and heavily used in the context of concurrent program
%% verification~\cite{DBLP:journals/lmcs/KobayashiSW06,DBLP:journals/tcs/IgarashiK04,DBLP:conf/esop/HondaVK98}. The
%% behavior of a program in our paper is abstracted as CCS-like
%% processes~\cite{DBLP:journals/iandc/MilnerPW92a}. For example, the
%% behavior of function $h$ is as $\mu
%% \alpha. \Malloc;\Malloc;\Free;\Free;\alpha$ which denotes it executes
%% $\Malloc$ twice, $\Free$ twice and calls itself. Similarly, the
%% behavior of $h'$ is abstracted as $\mu
%% \alpha. \Malloc;\Malloc;\alpha;\Free;\Free$.

%% One thing we should consider is like the function $f$ shown in Figure~\ref{ex:bbd}. The behavior of function $f$ is that $\Malloc$ twice, $\Free$ twice and calling itself. The abstracted behavior is $\mu \alpha. \Malloc;\Malloc;\Free;\Free;\alpha$. The number of allocation and deallocation is balanced before recursive call; the function is safe in our behavior type system, but it causes double frees: the variable $x$ is deallocated twice.
%% \begin{figure}[h]
%% 1  \Rtab\dtb\dtb $f(x)$= \\
%% 2  \dtb \dtb\dtb$\LET \; x = \MALLOC  \; \IN$ \\
%% 3  \dtb \dtb\dtb$\LET \; y = \MALLOC  \; \IN$ \\
%% 4  \dtb \dtb\dtb$\Free(y)$; $\Free(y) $;\;$f(x)$
%% \caption{balanced but double free}
%% \label{ex:bbd}
%% \end{figure}

%% Thanks to the \textbf{SK} type system, proposed by Suenaga and Kobayashi, it guarantees no double frees or illegal access to a deallocated memory cell. By combining the \textbf{SK} type system, our behavior type system can ignore the relationship between variables and pointers, so to estimate the upper bound of consumption memory cells according to the abstraction of the behavior of programs is sound.

%% \subsection{Overview of the algorithm}

%% \begin{figure}
%%  \centering
%% \includegraphics[width=10cm]{overview.jpg}
%% \caption{Overview of the algorithm}
%% \label{fig:ov}
%% \end{figure}

%% %% <<<<<<< HEAD
%% %% A program is first checked by $\mathbf{SK}$ type system; it is passed
%% %% to the behavioral type system proposed in our paper if its partial
%% %% correctness is guaranteed, otherwise returns ``it is not safe''; the
%% %% behavioral type system will check it and produce a behavioral type $P$
%% %% which abstracts the behavior of the program; and then by modeling the
%% %% behavioral type $P$ using model checkers like \texttt{SPIN} or
%% %% \texttt{CPAChecker} to verify whether the behavioral correctness of
%% %% the program is guaranteed. If its behavioral correctness is verified
%% %% by model checker, the safe memory deallocation for this program is
%% %% ensured, otherwise return ``it is not safe''.
%% %% =======
%% As represented in Figure~\ref{fig:ov}, a program is first checked by \textbf{SK} type system; if the properties about no double frees or illegal read/write operations to a deallocated memory cell is guaranteed, then it returns ``OK'' and the program is passed to our behavior type system, and it returns ``NG'' otherwise; our behavior type system will produce a behavioral type, and this behavioral type is passed to a model checker like \texttt{SPIN} or \texttt{CPAChecker} to verify whether it is consumed upper bound of memory cells.

%% Hence, by using our type system with \textbf{SK} type system, we can verify memory-leak freedom even for nonterminating programs.
%% %% >>>>>>> 9a92815042ab957eb9b2d406af7a45d4abb729b3

\paragraph{Notation} We write \(\vec{X}\) for a finite sequence of
\(X\); its length, if we do not explicitly mention, is clear from the
context or does not matter.

%% <<<<<<< HEAD
%% \subsection{Syntax}
%% \label{sec:languageSyntax}
%% =======
\paragraph{Notation.} we write $\vec{x}$ for a sequence $x_{1} \dots x_{n}$, and $x_{1} \dots x_{n}$ are pairwise-distinct; $f\{x\rightarrow v \}$ denotes a function $f'$ such that $f'(y) = v$ if $x = y$, otherwise $f'(y) = f(y)$ and $y \in dom(f)$; $[v/x]s$ denotes that substituting $v$ for $x$ in $s$.
%% >>>>>>> 9a92815042ab957eb9b2d406af7a45d4abb729b3

\todo{Revised}

The following BNF defines our language \(\mathcal{L}\).

\begin{eqnarray*}
  s \mbox{ (statements)} & ::= &  \SKIP \mid s_{1};s_{2} \mid *x \leftarrow y \mid \Free(x) \\
  & \mid & \LET x = \MALLOC \IN s \mid \LET x = \NULL\ \IN s  \\
  & \mid & \LET x = y \; \IN s \mid   \LET x = *y \; \IN s \\
  & \mid & \IFNULL(x) \; \THEN s_{1}\; \ELSE s_{2} \mid f(\vec{x})\\
  d \mbox{ (proc. defs.)} & ::= & \set{f \mapsto (x_1,\dots,x_n)s}\\
  P \mbox{ (programs)} &::=& \langle d_1 \cup \dots \cup d_n, s \rangle\\
\end{eqnarray*}

The language is equipped with procedure calls, dynamic memory
allocation and deallocation, and memory accesses with pointers.
\(\mathbf{Var}\) is a countably infinite set of \emph{variables}
ranged over by \(w, x, y\), and \(z\).  The statement \(\SKIP\) does
nothing.  The statement \(s_1;s_2\) executes \(s_1\) and \(s_2\)
sequentially.  The statement \(*x \leftarrow y\) writes \(y\) to the
memory cell that \(x\) points to.  The statement \(\LET x = e\ \IN s\)
evaluates the expression \(e\), binds \(x\) to the result, and
executes \(s\).  The expression \(\Malloc()\) allocates a new memory
cell and evaluates to the pointer to the cell.  The expression
\(\NULL\) evaluates to the null pointer.  The expression \(y\)
evaluates to its value.  The expression \(*y\) evaluates to the value
in the memory cell that \(y\) points to.  The statement
\(\IFNULL(x)\ \THEN\ s_1\ \ELSE\ s_2\) executes \(s_1\) if \(x\) is
\(\NULL\) and executes \(s_2\) otherwise.  The statement
\(f(\vec{x})\) calls procedure \(f\) with arguments \(\vec{x}\).

A procedure definition ranged over by \(d\) is a map from a procedure
name to an abstraction of the form \((\vec{x})s\).  We use a
metavariable \(D\) for a set of function definitions \(d_1 \cup \dots
\cup d_n\).  A program is a pair of function definitions \(D\) and a
main statement \(s\).

%% A program is a pair $(D,s)$, where $D$ is the set of definition.\\ The
%% command $\SKIP$ does nothing. The command $s_{1};s_{2}$ is executed as
%% a sequence, first executing $s_{1}$ and then $s_{2}$. The command $*x
%% \leftarrow y$ updates the content of the memory cell which is pointed
%% by pointer $x$ with value $y$. The command $\Free \Cirx$ deallocates
%% the memory cell which is pointed by a pointer $x$. Then command $\LET
%% x = e \; \IN s$ first evaluates the expression $e$ and binds the
%% return value of $e$ to $x$ and then executes statement $s$. The
%% command $\LET x = \Malloc \; \IN s$ first allocates a memory cell to a
%% pointer $x$ and then executes the statement $s$. The command $\LET x =
%% \NULL \IN s$ first allocates a null pointer to $x$ and then executes
%% $s$. The command $\LET x = y \; \IN s$ assign the pointer $y$ to $x$,
%% so the pointer $x$ and $y$ are said aliases for the same memory cell,
%% and then executes statement $s$. The command $\LET x = *y \; \IN s$
%% transfers a part of memory cells pointed by $y$ and then executes
%% statement $s$. The command $\IFNULL(x) \; \THEN s_{1} \; \ELSE s_{2}$
%% denotes that executing statement $s_{1}$ if pointer $x$ is a null
%% pointer, otherwise executing statement $s_{2}$. The command
%% $f(\vec{x})$ is a function call in which $\vec{x}$ denotes mutually
%% distinct variables like \{$x_{1}, \dots, x_{n}$\}. The notation $d$
%% denotes the definition of function $f(\vec{x})$ which has a body of
%% statement $s$. And examples are described by this syntax you can see
%% in Figure 1 and Figure 2.

\subsection{Operational Semantics}
\label{sec:languageSemantics}

This section introduce the operational semantics of \(\mathcal{L}\).
\(\mathcal{H}\) is a countably infinite set of \emph{locations} ranged
over by \(l\).

We give the operational semantics of the language \(\mathcal{L}\) as a
labeled transition on \emph{configurations} \(\langle H, R, s, n
\rangle\).  A configuration consists of the following four components:
\begin{itemize}
\item \(H\), a \emph{heap}, is a finite mapping from \(\mathcal{H}\)
  to \(\mathcal{H} \cup \set{\NULL}\);
\item \(R\), an \emph{environment}, is a finite mapping from \(\VAR\)
  to \(\mathcal{H} \cup \set{\NULL}\);
\item \(s\) is the statement that is being executed; and
\item \(n\) is a natural number that represents the number of
  available memory cells.
\end{itemize}
\(n\) in a configuration is later used to formalize memory leak caused
by nonterminating program.

The operational semantics is given by a labeled translation relation
\(\langle H, R, s, n \rangle \xlongrightarrow{\rho}_D \langle H', R',
s', n' \rangle\) where \(\rho\), an \emph{action}, is \(\Malloc\),
\(\Free\), or \(\tau\).  The action \(\Malloc\) expresses an
allocation of a memory cell; \(\Free\) expresses a deallocation;
\(\tau\) expresses the other actions.  We often omit \(\tau\) in
\(\xlongrightarrow{\tau}_D\).  We use a metavariable \(\sigma\) for a
finite sequence of actions \(\rho_1\dots\rho_n\).  We write
\(\xlongrightarrow{\rho_1\dots\rho_n}_D\) for
\(\xlongrightarrow{\rho_1}_D\xlongrightarrow{\rho_2}_D\dots\xlongrightarrow{\rho_n}_D\).
We write \(\xLongrightarrow{\rho}_D\) for
\(\xlongrightarrow{}_D^*\xlongrightarrow{\rho}_D\xlongrightarrow{}_D^*\).
We write \(\xLongrightarrow{\rho_1\dots\rho_n}_D\) for
\(\xLongrightarrow{\rho_1}_D\dots\xLongrightarrow{\rho_n}_D\).

%% Because we want to estimate the number of available memory cells at
%% every operation step, we extend the triple $\langle H\coma R\coma s
%% \rangle$ that is represented as run-time state in previous type system
%% to a quadruple $\langle H\coma R\coma s\coma n \rangle$ in our
%% paper. The introduced notation $n$ denotes the number of available
%% memory cells, a nature number. When executing the operation $\Malloc$,
%% the number of available memory cells will decrease 1, which is denoted
%% as ($n - 1$); when executing the operation $\Free$, the number of
%% available memory cells will increase 1, which is denoted as ($n +
%% 1$). The notation $H$, which models heap memory, is a mapping from
%% finite subset of $\mathcal{H}$ to $\mathcal{H}$ $\cup$ \{$null$\},
%% where $\mathcal{H}$ represents the set of \emph{heap addresses}. $R$,
%% which models registers, is a mapping from finite set of variables to
%% $\mathcal{H}$ $\cup$ \{$null$\}.

Figure~\ref{fig:transitionRules} defines the relation
\(\xlongrightarrow{\rho}_D\).

%% <<<<<<< HEAD
\begin{figure}
\begin{minipage}{\textwidth}
%% =======
%% %% Transition rules are listed in Figure 3. In these rules, $f\{x\to v\}$ is defined as a function $f'$ such that $f'(y) = v$ if $x = y$, otherwise $f'(y) = f(y)$ and $y \in dom(f)$. There are three rules about $\mathbf{NullEx}$ which denotes accessing a null pointer, three rules about $\mathbf{Error}$ for accessing a deallocated memory cell, and one rule about $\mathbf{Error}$ which denotes allocating a memory cell when there is no memory space.
%% %\begin{figure}[h]
%% % Skip Command
%% Runtime state is represented by $\langle H, R, s, n \rangle$, where $H$ is a mapping from finite subset of $\mathcal{H}$ to $\mathcal{H}$ $\cup$ \{$null$\}, in which $\mathcal{H}$ represents the set of \emph{heap addresses}, intuitively, the $H$ models a heap memory; $R$, which models registers, is a mapping from finite set of variables to $\mathcal{H}$ $\cup$ \{$null$\}.

%% Operational semantics are defined by the relations: $\rightarrow_{D}, \xlongrightarrow{\Malloc}_{D}, and \xlongrightarrow{\Free}_{D} $, in which $\xlongrightarrow{\Malloc}_{D}, and \xlongrightarrow{\Free}_{D} $ denote performing a allocation and deallocation operation respectively, and $\rightarrow_{D}$ expresses that performing an internal action like $\SKIP$ or assignment.
%% >>>>>>> 9a92815042ab957eb9b2d406af7a45d4abb729b3

\infax[Tr-Skip]
{\langle H, R, \SKIP;s, n \rangle
\longrightarrow_{D}
\langle H, R, s, n \rangle}

\infrule[Tr-Assignment]
    {  R(x) \in dom(H)}
    {  \langle H, R, *x \leftarrow y , n \rangle
              \longrightarrow_{D}
              \langle H \Lfc R(x) \rightarrow R(y) \Rfc , R,   \SKIP , n  \rangle }
\infrule[Tr-Free]
{R(x) \in dom(H) , n \in \mathbb{N}}
{\langle H\coma R\coma  \FREE , n \rangle
             \xlongrightarrow{\Free}_{D}
             \langle H\backslash \Lfc R(x) \Rfc \coma R \coma   \SKIP , n+1  \rangle }

\infrule[Tr-LetNull]
{x' \notin dom(R)}
{\langle H\coma R\coma  \LET x = \NULL \IN s , n \rangle
  \longrightarrow_{D}
  \langle H\coma R\Lfc x' \rightarrow \NULL \Rfc \coma   \Lb x'/x \Rb s , n  \rangle }

\infrule[Tr-LetEq]
{x' \notin dom(R)}
{\langle H\coma R\coma \LET x = y \; \IN s , n \rangle
  \longrightarrow_{D}
  \langle H\coma R\Lfc x' \rightarrow R(y) \Rfc \coma   \Lb x'/x \Rb s , n  \rangle }

\infrule[Tr-LetDref]
{x' \notin dom(R)}
{\langle H\coma R\coma  \LET x = *y \; \IN s , n \rangle
  \longrightarrow_{D}
  \langle H\coma R\Lfc x' \rightarrow H(R(y)) \Rfc \coma   \Lb x'/x \Rb s , n  \rangle }

\infrule[Tr-Malloc]
{h \notin dom(H)}
{\langle H\coma R\coma  \LET x = \Malloc() \; \IN s , n \rangle
  \xlongrightarrow{\Malloc}_{D}
  \langle H \Lfc h \rightarrow v\Rfc \coma R\Lfc x' \rightarrow h \Rfc \coma   \Lb x'/x \Rb s , n-1  \rangle }

\infrule[Tr-IfNullT]
{R(x) = \NULL}
{\langle H \coma R \coma \IFNULL\Cirx   \THEN   s_{1} \ELSE\  s_{2} \coma  n \rangle
  \longrightarrow_{D}
  \langle H\coma R\coma s_{1} \coma n \rangle}

\infrule[Tr-IfNullF]
{R(x) \neq \NULL}
{\langle H \coma R \coma \IFNULL\Cirx \THEN  s_{1} \ELSE  s_{2} \coma  n \rangle
  \longrightarrow_{D}
  \langle H\coma R\coma s_{2} \coma  n, \rangle}

\infrule[Tr-Call]
{f(\vec{y}) = s \in D}
{ \langle H\coma R\coma  f(\vec{x}) , n \rangle
  \longrightarrow_{D}
  \langle H\coma R\coma  \Lb \vec{x}/\vec{y} \Rb s , n \rangle}

\infrule[Tr-AssignNullError]
{R(x) = null}
{\langle H\coma R\coma  *x \leftarrow y , n \rangle
  \longrightarrow_{D} \bf NullEx }

\infrule[Tr-DrefNullError]
{R(y) = null}
  {\langle H\coma R\coma  x = *y, n \rangle
    \longrightarrow_{D}
    \bf NullEx }

  \infrule[Tr-FreeNullError]
  {R(x) =  null }
  {\langle H\coma R\coma  \FREE , n \rangle
    \xlongrightarrow{\Free}_{D} \bf NullEx  }
\infrule[Tr-AssignError]
{R(x) \notin dom(H) \cup \Lfc null \Rfc}
{\langle H\coma R\coma   *x \leftarrow y,  n \rangle
  \longrightarrow_{D}
  \bf  Error }

\infrule[Tr-DrefError]
{R(y) \notin dom(H) \cup \Lfc null \Rfc}
{\langle H\coma R\coma  \LET x  = *y \; \IN s, n \rangle
  \longrightarrow_{D}
  \bf  Error }

\infrule[Tr-FreeError]
{R(x) \notin dom(H) \cup \Lfc null \Rfc}
{\langle H\coma R\coma  \FREE , n \rangle
  \xlongrightarrow{\Free}_{D}
  \bf Error }

\infax[Tr-MallocError]
{ \langle H\coma R\coma \LET x = \Malloc() \ \IN s ,  0  \rangle    \xlongrightarrow{\Malloc}_{D}
      \mathbf{Error}}


\todo{Complete this figure.  Read the header of bcprules.sty for the
  usage of infax and infrule macros.}

\end{minipage}
\label{fig:transitionRules}
\caption{Definition of the labeled transition \(\langle H, R, s, n
  \rangle \xlongrightarrow{\rho}_D \langle H', R', s', n' \rangle\).}
\end{figure}

%% Transition rules are listed in Figure 3. In these rules, $f\{x\to v\}$
%% is defined as a function $f'$ such that $f'(y) = v$ if $x = y$,
%% otherwise $f'(y) = f(y)$ and $y \in dom(f)$. There are three rules
%% about $\mathbf{NullEx}$ which denotes accessing a null pointer, three
%% rules about $\mathbf{Error}$ for accessing a deallocated memory cell,
%% and one rule about $\mathbf{Error}$ which denotes allocating a memory
%% cell when there is no memory space.
%% %\begin{figure}[h]
%% % Skip Command
%% Runtime state is represented by $\langle H, R, s, n \rangle$, where
%% Operational semantics is defined by the relations\\
%% $\rightarrow_{D}, \xlongrightarrow{\Malloc}_{D}, and \xlongrightarrow{\Free}_{D} $ defined by the rules in ....\\
%% Here, $\rightarrow_{D}$ expresses; ....\\

%% $$
%%     \frac{n \in \mathbb{N}}
%%             {\langle H\coma R\coma  \SKIP;s , n \rangle
%%               \longrightarrow_{D}
%%                 \langle H\coma R\coma   s , n \rangle }
%%      \Rtab \mbox{(E-Skip)}
%% $$
%% % Assignment
%% $$
%%      \frac{R(x) \in dom(H), n \in \mathbb{N}}
%%            {\langle H\coma R\coma  *x \leftarrow y , n \rangle
%%              \longrightarrow_{D}
%%              \langle H \Lfc R(x) \rightarrow R(y) \Rfc \coma R \coma   \SKIP , n  \rangle }
%%      \Rtab \mbox{(E-Assign)}
%% $$
%% % Free Command
%% $$
%%      \frac{R(x) \in dom(H) , n \in \mathbb{N}}
%%           {\langle H\coma R\coma  \FREE , n \rangle
%%             \xlongrightarrow{\Free}_{D}
%%             \langle H\backslash \Lfc R(x) \Rfc \coma R \coma   \SKIP , n+1  \rangle }
%%      \Rtab \mbox{(E-Free)}
%% $$
%% % Let Null Command
%% $$
%%      \frac{x' \notin dom(R)}
%%            {\langle H\coma R\coma  \LET x = \NULL \IN s , n \rangle
%%              \longrightarrow_{D}
%%              \langle H\coma R\Lfc x' \rightarrow \NULL \Rfc \coma   \Lb x'/x \Rb s , n  \rangle }
%%      \Rtab \mbox{(E-LetNull)}
%% $$
%% % Let Eq Command
%% $$
%%      \frac{x' \notin dom(R)}
%%             {\langle H\coma R\coma \LET x = y \; \IN s , n \rangle
%%               \longrightarrow_{D}
%%               \langle H\coma R\Lfc x' \rightarrow R(y) \Rfc \coma   \Lb x'/x \Rb s , n  \rangle }
%% \Rtab \mbox{(E-LetEq)}
%% $$
%% % Reference Command
%% $$
%%      \frac{x' \notin dom(R)}
%%             {\langle H\coma R\coma  \LET x = *y \; \IN s , n \rangle
%%               \longrightarrow_{D}
%%               \langle H\coma R\Lfc x' \rightarrow H(R(y)) \Rfc \coma   \Lb x'/x \Rb s , n  \rangle }
%%      \Rtab \mbox{(E-LetDref)}
%% $$
%% % Malloc (allocate) Command
%% $$
%%      \frac{h \notin dom(H)}
%%             {\langle H\coma R\coma  \LET x = \Malloc() \; \IN s , n \rangle
%%               \xlongrightarrow{\Malloc}_{D}
%%               \langle H \Lfc h \rightarrow v\Rfc \coma R\Lfc x' \rightarrow h \Rfc \coma   \Lb x'/x \Rb s , n-1  \rangle }
%% \Rtab \mbox{(E-Malloc)}
%% $$
%% % IFNULL T
%% $$
%%     \frac{R(x) = \NULL}
%%            {\langle H \coma R \coma \IFNULL\Cirx   \THEN   s_{1} \ELSE\  s_{2} \coma  n \rangle
%%            \longrightarrow_{D}
%%            \langle H\coma R\coma s_{1} \coma n \rangle}
%%     \Rtab \mbox{(E-IfNullT)}
%% $$
%% % IFNULL F
%% $$
%%     \frac{R(x) \neq \NULL}
%%            {\langle H \coma R \coma \IFNULL\Cirx \THEN  s_{1} \ELSE  s_{2} \coma  n \rangle
%%            \longrightarrow_{D}
%%            \langle H\coma R\coma s_{2} \coma  n, \rangle}
%%     \Rtab \mbox{(E-IfNullF)}
%% $$
%% % Function Call
%% $$
%%      \frac{f(\vec{y}) = s \in D}
%%             { \langle H\coma R\coma  f(\vec{x}) , n \rangle
%%                \longrightarrow_{D}
%%                \langle H\coma R\coma  \Lb \vec{x}/\vec{y} \Rb s , n \rangle}
%%       \Rtab \mbox{(E-Call)}
%% $$
%% % Error : access the null memory cell
%% $$
%%       \frac{R(x) = null}
%%             {\langle H\coma R\coma  *x \leftarrow y , n \rangle
%%               \longrightarrow_{D}
%%              \bf NullEx }
%%       \Rtab \mbox{(E-AssignNullError)}
%% $$
%% % ERROR : access the null memory cell
%% $$
%%       \frac{R(y) = null}
%%              {\langle H\coma R\coma  x = *y, n \rangle
%%                \longrightarrow_{D}
%%               \bf NullEx }
%%              \Rtab \mbox{(E-DrefNullError)}
%% $$
%% $$
%%      \frac{R(x) =  null }
%%            {\langle H\coma R\coma  \FREE , n \rangle
%%              \xlongrightarrow{\Free}_{D} \bf NullEx  }
%%       \Rtab \mbox{(E-FreeNullError)}
%% $$
%% % ERROR :
%% $$
%%      \frac{R(x) \notin dom(H) \cup \Lfc null \Rfc}
%%            {\langle H\coma R\coma   *x \leftarrow y,  n \rangle
%%              \longrightarrow_{D}
%%            \bf  Error }
%%     \Rtab \mbox{(E-AssignError)}
%% $$
%% % ERROR
%% $$
%%       \frac{R(y) \notin dom(H) \cup \Lfc null \Rfc}
%%            {\langle H\coma R\coma  \LET x  = *y \; \IN s, n \rangle
%%               \longrightarrow_{D}
%%                 \bf  Error }
%%       \Rtab \mbox{(E-DrefError)}
%% $$
%% %
%% $$
%%       \frac{R(x) \notin dom(H) \cup \Lfc null \Rfc}
%%             {\langle H\coma R\coma  \FREE , n \rangle
%%               \xlongrightarrow{\Free}_{D}
%%               \bf Error }
%%      \Rtab \mbox{(E-FreeError)}
%% $$
%%  % ERROR: no enough space
%% $$
%%       \langle H\coma R\coma \LET x = \Malloc() \ \IN s ,  0  \rangle
%%       \xlongrightarrow{\Malloc}_{D}
%%       \mathbf{Error}
%%       \Rtab \mbox{(E-MallocError)}
%% $$
%% $$
%%      \mathbf{Figure \; 3.} \;\;  \mbox{ Operational Semantics}
%% $$
%
%\caption{Operational Semantics.}
%\label{example:os}
     %\end{figure}
\begin{myDef}
\todo{Formally state this definition.}
memory leaks: if a program consumes unbounded number of memory cells.\\
memory-leak \ freedom: $\exists n \in \mathbb{N}$ s.t. $\langle \emptyset, \emptyset, s, n \rangle \nrightarrow^{*}Error$
\label{df:ml}
\end{myDef}

\section{Type System}

\subsection{Syntax of Types}
     \begin{eqnarray*}
       P (\mathit{behavioral\ types})::=&& {\bf 0} \tB P_{1};P_{2} \tB P_{1}+P_{2} \tB \Malloc\\
       &&\tB \Free \tB \alpha \tB \mu\alpha.P \\
       \sigma (\mathit{function\ types})::=&& (\tau_{1},\dots, \tau_{n}) P
     \end{eqnarray*}

The type $\bf 0$ abstracts the behavior of $\SKIP$ and means "does nothing". $P_{1};P_{2}$ is for sequential execution. $P_{1} + P_{2}$ is abstracted as conditional. $\Malloc$ is the behavior of a statement that allocates a memory cell exactly once. $\Free$ is for deallocating memory cell exactly once. $\mu \alpha. P$ is a recursive type. For example, the behavior of  the body of function $h$ in Figure 2 is abstracted as $\mu \alpha. \Malloc;\Malloc;\Free;\Free;\alpha$. $\alpha$ is a type variable and bounded to the recursive constructor $\mu \alpha$.

The only value in our paper is reference, and its type is $\mathbf{Ref}$.

The function type is described as $(\tau_{1}, \dots, \tau_{n})P$, which means a function receives some pointers as arguments and its body is abstracted as a behavioral type $P$.

% Semantics of Behavioral Types %
\subsection{Semantics of Behavioral Types}
The semantics of behavioral type are given by labeled transition system, and listed as follows:
    $$
        \mathbf{0};P \rightarrow P
    $$
    $$
          \Malloc \xlongrightarrow{\Malloc} 0
    $$
    $$
           \Free \xlongrightarrow{\Free} 0
    $$
    $$
          \mu \alpha.P \rightarrow  [\mu \alpha . P/\alpha]  P
    $$
   $$
          P_{1} + P_{2} \longrightarrow P_{1}
   $$
   $$
          P_{1} + P_{2} \longrightarrow P_{2}
   $$
   $$
           \frac{P_{1} \xlongrightarrow{\alpha} P_{1}' }
                 {P_{1};P_{2} \xlongrightarrow{\alpha} P_{1}';P_{2}}
   $$
The notation $\rightarrow$ denotes that a behavioral type can be reduced by the internal action. Notation $\xlongrightarrow{\alpha}$ means that a behavioral type can be reduced by executing $\alpha$ actions, and the $\alpha$ here is $\{\Malloc, \Free\}$.

% Type Judgments
\subsection{Typing Rules}
The type judgment of our type system is given by the form $\Theta ; \Gamma \vdash s : P$, where $\Theta$ is a mapping from function variables to function types, $\Gamma$ is a type environment that denotes a mapping from variables to value types.
It reads ``the behavior of $s$ is abstracted as $P$ under $\Theta$ and $\Gamma$ environments''. We design the type system so that this type judgment implies the property: when $s$ executes $\Malloc$(resp.$\Free$), then $P$ is equivalent to $\Malloc;P'$(resp.$\Free;P'$) for a type $P'$ such that $\Theta; \Gamma \vdash s': P'$, where $s'$ is the continuation of $s$. This property guarantees the behavioral type soundly abstracts the upper bound of the consumed memory cells.

Typing rules are presented in Figure~\ref{fig:typingrules}. In the rule for assignment, the behavior of  $*x \leftarrow y$ is $\bf 0$. The rule for $\Free$ represents that the behavior of $\Free \Cirx$ is $\Free$. The rule T-Malloc represents that $\LET x = \MALLOC \; \IN s$ has the behavior $\Malloc;P$, where $P$ is the behavior of statement $s$. The rule for function call represents that function $f$ has the behavior $P$ which is the behavior of the body of this function .

In the rule for subtyping, $P_{1} \le P_{2}$ represents that $P_{1}$ is the subtype of $P_{2}$ and  means that: \\
(1) if $P_{1} \xlongrightarrow{\alpha}  P_{1}'$ then $\exists P_{2}' $ s.t. $P_{2} \overset{\text{$\alpha$}}{\Longrightarrow} P_{2}'$ and $ P_{1}' \le P_{2}' $\\
(2) if $P_{1} \rightarrow P_{1}'$ then $\exists P_{2}'$ s.t. $P_{2} \rightarrow^{*} P_{2}'$ and  $P_{1}' \le P_{2}'$\\
where $\overset{\text{$\alpha$}}{\Longrightarrow}$ means that: $\rightarrow^{*} \xlongrightarrow{\alpha} \rightarrow^{*}$.

At the end of $s$, memory leak freedom is guaranteed by $OK_{n}(P)$ ,where $P$ is the behavior of $s$. $OK_{n}(P)$ is defined as Definition~\ref{df:okn} in which $\sharp_{malloc}(\alpha)$ and $\sharp_{free}(\alpha)$ are functions to count the number of $\Malloc$ and $\Free$ actions in $\alpha$ respectively. This definition, intuitively, means at every running step the number of allocated memory cells will never go out of memory scope.
\begin{myDef}
  $OK_{n}(P) \iff \forall P',\; P \xlongrightarrow{\alpha}^{*}P'$ then $\sharp_{malloc}(\alpha)-\sharp_{free}(\alpha)\le n$.
\label{df:okn}
\end{myDef}

\begin{figure}
\begin{minipage}{12cm}

% Skip type
$$
         \Theta ; \Gamma \vdash \SKIP : \mathbf{0}
      \Rtab \mbox{(T-Skip)}
$$
% Sequence type
$$
      \frac{\Theta ; \Gamma \vdash s_{1} : P_{1} \Rtab \Theta ; \Gamma \vdash s_{2} : P_{2}}
          {\Theta ; \Gamma \vdash s_{1} ; s_{2} : P_{1};P_{2} }
     \Rtab \mbox{(T-Seq)}
$$
% Assignment type
$$
     \frac{\Theta ; \Gamma \vdash y  \Rtab \Theta ; \Gamma \vdash x }
          {\Theta ; \Gamma \vdash *x \leftarrow y : \mathbf{0} }
     \Rtab \mbox{(T-Assign)}
$$
% Free(deallocate) type
$$
     \frac{\Theta ; \Gamma \vdash x  }
           {\Theta ; \Gamma \vdash \Free(x) : \Free}
     \Rtab \mbox{(T-Free)}
$$
% Malloc type
$$
     \frac{\Theta ; \Gamma,x \vdash s : P}
           {\Theta ; \Gamma \vdash \LET x = \MALLOC \; \IN s  : \Malloc;P}
           \Rtab \mbox{(T-Malloc)}
$$
% Let eq type
$$
     \frac{\Theta ; \Gamma \vdash y   \Rtab \Theta ; \Gamma , x  \vdash s : P}
           {\Theta ; \Gamma \vdash \LET x = y \; \IN s : P}
     \Rtab \mbox{(T-LetEq)}
$$
% Dereference type
$$
     \frac{\Theta ; \Gamma \vdash y  \Rtab \Theta ; \Gamma , x  \vdash s : P}
           {\Theta ; \Gamma \vdash \LET x = *y \; \IN s : P}
     \Rtab \mbox{(T-LetDref)}
$$
% Let NULL type
$$
     \frac{\Theta ; \Gamma, x  \vdash s : P}
           {\Theta ; \Gamma \vdash \LET x = \mathbf{null} \; \IN s : P}
     \Rtab \mbox{(T-LetNull)}
$$
% Subtyping
$$
     \frac{\Theta ; \Gamma \vdash s : P_{1} \Rtab P_{1} \le P_{2}}
            {\Theta ; \Gamma \vdash s : P_{2}}
     \Rtab \mbox{(T-Sub)}
$$
 % ifnull s then s type
$$
     \frac{\Theta ; \Gamma \vdash x    \ \ \ \  \Theta ; \Gamma \vdash s_{1} : P \ \ \ \ \Theta ; \Gamma \vdash s_{1} : P}
           {\Theta ; \Gamma \vdash \IFNULL(x) \; \THEN s_{1}\; \ELSE s_{2} : P}
     \Rtab \mbox{(T-IfNull)}
$$
% Function call type
$$ \frac{ \Theta(f) = P}
{\Theta; \Gamma, \vec{x} : \vec{\tau} \vdash f(\vec{x}) : P}
\Rtab \mbox{(T-Call)} $$
% Program
$$\frac{\vdash D : \Theta \;\;\;\; \Theta; \emptyset\vdash s : P \Rtab OK_{n}(P)}
{\vdash (D, s)}
\Rtab \mbox{(T-Program)} $$
\end{minipage}
\caption{Typing Rules}
\label{fig:typingrules}
\end{figure}

\subsection{Type Soundness}
This subsection describes some theorems and lemmas for type safety.
\begin{theorem}\label{thm1}
If $\vdash (D, s)$ then $(D, s)$ does not lead to $memory\;leak$.\\
Memory leak freedom: $\exists n \in \mathbb{N}$ s.t.
$\langle \emptyset, \emptyset, s, n \rangle \nrightarrow^{*}Error$
\end{theorem}
\noindent
This theorem says that a well typed program guarantees memory leak freedom.
% Lemma Preservation %
\begin{lemma}[Preservation $\mathbf{I}$]%\label{preser}
If $OK_{n}(P)$, $\Theta; \Gamma \vdash s : P$ and $\langle H,R,s, n \rangle
\xlongrightarrow{\alpha}\langle H',R',s', n'
\rangle$, then $\exists P'$ s.t. \\
(1) $ \Theta; \Gamma \vdash s' : P' $ \\
(2) $ P \overset{\text{$\alpha$}}{\Longrightarrow} P'$\\
(3) $ OK_{n'}(P') $
\end{lemma}
\begin{lemma}[Preservation $\mathbf{II}$]%\label{preser}
If $OK_{n}(P)$, $\Theta ; \Gamma \vdash s : P$ and $\langle H,R,s,n \rangle
\rightarrow \langle H',R',s', n'
\rangle$, then $\exists P'$ s.t. \\
(1) $\Theta; \Gamma \vdash s' : P'$\\
(2) $ P \rightarrow^{*} P'  $\\
(3) $OK_{n'}(P')$
\end{lemma}
\begin{lemma}%\label{error}
 The partial correctness is guaranteed $\vdash \langle H,R,s \rangle$ , so that if $\vdash \langle H,R,s,n \rangle$, then $\vdash \langle H',R',s',n' \rangle \nrightarrow Error$
\end{lemma}
\section{Type Inference Algorithm}
This section describes how to construct syntax directed typing rules according to the typing rules of above section, and it provides an algorithm which inputs statements and returns a pair containing constraints and behavior types.
\subsection{Constraints Generation}
By syntax directed typing rules, the type inference algorithm has been designed as in Figure~\ref{fig:tyin}.

Function $PT_{v}(x) = (C,\emptyset)$ denotes that it receives a pointer variable $x$ and outputs a pair consisting of constraints set $C$ and an empty set. $PT_{\Theta}(s) = (C, P)$ is a mapping from statements to a pair --  constraints set $C$ and behavioral types $P$, where $\Theta$ is mapping from function names to function types. $PT(\langle D,s \rangle) = (C, P)$ denotes that it receives a program and produces a pair $(C, P)$. $\alpha_{i}$ and $\beta$ are fresh type variables.

\begin{figure}
\begin{boxedminipage}{8cm}
  \scriptsize
\begin{nospaceflalign*}
   PT_{\Theta}(f) &  =  &\\
  & \ \  \LET  \alpha = \Theta(f) & \\
  & \ \ \IN   (C = \{\alpha \le \beta \}, \beta) &
\end{nospaceflalign*}
\begin{nospaceflalign*}
   PT_{\Theta}(\SKIP) &  =  (\emptyset, 0)&
\end{nospaceflalign*}
\begin{nospaceflalign*}
   PT_{\Theta}(s_{1}&;s_{2})  =  &\\
   & \ \ \ \LET (C_{1}, P_{1}) = PT_{\Theta}(s_{1}) & \\
   &\ \ \ \ \ \ \  \ (C_{2}, P_{2}) = PT_{\Theta}(s_{2}) & \\
   & \ \ \ \IN   (C_{1} \cup C_{2}\cup \{P_{1}; P_{2} \le \beta \}, \beta) &
\end{nospaceflalign*}
\begin{nospaceflalign*}
   PT_{\Theta}(*x& \leftarrow y)   =  &\\
  & \ \ \LET (C_{1}, \emptyset) = PT_{v}(*x) & \\
  & \ \ \ \ \ \ (C_{2}, \emptyset) = PT_{v}(y) & \\
  &\ \  \IN    (C_{1} \cup C_{2},  0) &
\end{nospaceflalign*}
\begin{nospaceflalign*}
   PT_{\Theta}(\Free(x)) &  = (\emptyset, \Free)  &
\end{nospaceflalign*}
\begin{nospaceflalign*}
   PT_{\Theta}(\LET &x = \Malloc() \  \IN s)  =  &\\
   &\LET (C_{1}, P_{1}) = PT_{v}(s) & \\
   &\IN  (C_{1} \cup \{P_{1} \le \beta \} ,  \Malloc; \beta) &
\end{nospaceflalign*}
\begin{nospaceflalign*}
   PT_{\Theta}(\LET &x = y \  \IN s )  =  &\\
   &  \LET (C_{1}, \emptyset) = PT_{v}(y) & \\
   & \ \ \ \ \ (C_{2}, P_{1}) = PT_{\Theta}(s) & \\
   &  \IN   (C_{1} \cup C_{2}\cup \{P_{1} \le \beta \},  \beta) &
\end{nospaceflalign*}
\begin{nospaceflalign*}
   PT_{\Theta}(\LET &x = *y \  \IN s )  =  &\\
   & \LET  (C_{1}, \emptyset) = PT_{v}(y) & \\
   &\ \ \ \ \ \ (C_{2}, P_{1}) = PT_{\Theta}(s) & \\
   & \IN   (C_{1} \cup C_{2}\cup \{P_{1} \le \beta \},  \beta) &
\end{nospaceflalign*}
\begin{nospaceflalign*}
   PT_{\Theta}(&\IFNULL(x) \  \THEN  s_{1} \  \ELSE \ s_{2} )  =  &\\
   & \ \ \ \ \ \LET  (C_{1}, P_{1}) = PT_{\Theta}(s_{1}) & \\
   &\ \ \ \ \  \ \ \ \ \ (C_{2}, P_{2}) = PT_{\Theta}(s_{2}) & \\
   &\ \ \ \ \  \ \ \ \ \ (C_{3}, \emptyset) = PT_{v}(x) & \\
   & \ \ \ \ \ \ \IN   (C_{1} \cup C_{2}\cup C_{3}\cup \{P_{1} \le \beta, P_{2} \le \beta \},  \beta) &
\end{nospaceflalign*}
\begin{nospaceflalign*}
   PT(\langle D, s \rangle&)   =  &\\
   &\LET  \Theta = \{ f_{1}:\alpha_{1}, \dots, f_{n}:\alpha_{n}  \} &\\
   & \ \ \ \ \  where \ \{ f_{1},\dots, f_{n} \} = dom(D) \ and \ \alpha_{1}, \dots, \alpha_{n} \  are \ fresh  & \\
   & \IN    \LET  (C_{i}, P_{i}) = PT_{\Theta}(D(f_{i})) \  for \  each \ i & \\
   & \IN    \LET  C_{i}^{'} = \{ \alpha_{i} \le P_{i} \} \ for \  each \ i & \\
   & \IN    \LET  (C, P) = PT_{\Theta}(s)  & \\
   & \IN   (C_{i} \cup C_{i}^{'} ) \cup C \cup  \{OK(P)\},  P) &
\end{nospaceflalign*}
\end{boxedminipage}
\caption{Type Inference Algorithm}
\label{fig:tyin}
\end{figure}

\subsection{Constraints Reduction}
$PT\langle D, s \rangle$ receives a program as argument and produces a pair which consists of the subtype constraints on behavior types of the form $\alpha \ge A$, and constraints of the form $OK_{n}(P)$. Thus, we obtain the following constraints:\\
$$
\{ \alpha_{1} \ge A_{1}, \dots, \alpha_{n} \ge  A_{n}, OK_{n}(P)\}
$$
Here, we can assume that $\alpha_{1}, \dots, \alpha_{n}$ are pairwise-distinct, since $\alpha \ge A_{1}$ and $\alpha \ge A_{2}$ can be replaced with $\alpha \ge A_{1}+A_{2}$ by lemma 3.8 in paper~\cite{DBLP:journals/lmcs/KobayashiSW06}. we can also assume that $\{ \alpha_{1}, \dots, \alpha_{n} \}$ contains all the type variables in the constraints, since otherwise we can always add the tautology $\alpha \ge \alpha$. Each subtype constraints $\alpha \ge A$ can be replaced by $\alpha \ge \mu \alpha. A$, by lemma 3.8(4)~\cite{DBLP:journals/lmcs/KobayashiSW06} ( substituting $\alpha$ for $B$ in this lemma). Therefore the above constraints can be further reduced to $OK_{n}([\vec{A} \backslash \vec{\alpha}])$. Here, $A'_{1}, \dots, A'_{n}$ are the least solutions for the subtype constraints.

\section{Preliminary Experiment}

\section{Related Work}

\section{Conclusion}

We have described a type-based approach to safe memory deallocation
for non-terminating programs. The approach is based on the idea of
decomposing safe memory memory deallocation into partial correctness,
which is verified by previous type system, and behavioral
correctness. We designed a behavioral type system in our paper for
verification of behavioral correctness. Currently, we are looking for
a model checker to estimate an upper bound of consumption given a
behavioral type and planning to implement a verifier and conduct
experiment to see whether our approach is feasible.

\bibliographystyle{abbrv}
\bibliography{tan}

\newpage
\appendix
\section*{Appendix}

\input{proof}
\input{sdtyping}

\end{document}
